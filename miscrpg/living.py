from muscular_system import MuscularCondition
from immune_system import ImmuneCondition
from sensory_system import SensoryCondition
from cardio_system import CardioCondition
from damageable import Damage, TurnBasedDamage, MixedDamage, SlashingDamage, BleedingDamage, CrushingDamage
from weapon import Limbs, Sword, NatureWeapon, Weapon, Club
from armor import LeatherArmor, Skin, Armor
from rpg_logs import battle_log
from copy import deepcopy

class Living:
    name = 'unknown'
    CRIPPLED_THRESHOLD = 0.6

    def __init__(self, name='nameless', muscular=1, immune=1, sensory=1, cardio=1, weight=100, perks=[]):
        self.name = name
        self.m = MuscularCondition(muscular)  # strength, mobility
        self.i = ImmuneCondition(immune)  # resistence to discease, poison
        self.s = SensoryCondition(sensory)  # initiative, ranged attack, precision (criticals)
        self.c = CardioCondition(cardio)  # energy, regeneration
        self.weight = weight
        self.perks = perks
        self.turn_based = [self.m, self.i, self.s, self.c]
        self.damageable = [self.m, self.i, self.s, self.c]
        self.weapon = Limbs()
        self.armor = Skin()
        for sub in self.turn_based:
            sub.owner = self.name  # no circular reference, just name

    def attack(self):
        battle_log.add('%s attacking:' % self.name)
        adjusted = []
        if isinstance(self.weapon.damage, MixedDamage):
            damages = self.weapon.damage.lst
        else:
            damages = [self.weapon.damage]
        for damage in damages:
            dmg = deepcopy(damage)
            #TODO: check weapon type when dealing damages, firearms are not based on muscle condition
            dmg_value = int(dmg.value * (self.m.value() / 100))
            battle_log.add('%s weapon [%s] damage increased by muscle: %d -> %d' % (self.name, dmg.name, dmg.value, dmg_value))
            dmg.value = dmg_value
            adjusted.append(dmg)
        if len(adjusted) > 1:
            return MixedDamage(adjusted)
        else:
            return adjusted[0]

    def defend(self, damage):
        battle_log.add('%s defending:' % self.name)
        if self.armor is not None:
            damage = self.armor.resist(damage)
        self.take_damage(damage)

    def health(self):
        return self.m.value() * self.s.value() // 100

    def energy(self):
        return self.c.value() // 10

    def regeneration(self):
        return self.c.value() // 70  # fail to regenrate if cardio condition lower than 70%

    def is_dead(self):
        some_sys_broken = False
        for sys in self.damageable:
            some_sys_broken = some_sys_broken or sys.is_broken()
            if some_sys_broken:
                break
        return some_sys_broken

    def is_disabled(self):
        return self.m.value() == 0

    def is_crippled(self):
        return (self.m.value() / self.m.max_value) < Living.CRIPPLED_THRESHOLD

    def is_paralyzed(self):
        return self.s.value() == 0

    def is_unconscious(self):
        return self.s.value() <= 0

    def speed(self):
        return self.weight / self.m.value()

    def status(self):
        text = ''
        if self.is_dead():
            return 'DEAD'
        if self.is_crippled():
            text += 'C'
        if self.is_disabled():
            text += 'D'
        if self.is_paralyzed():
            text += 'P'
        if self.is_unconscious():
            text += 'U'
        return text

    def take_turn(self):
        for x in self.turn_based:
            x.take_turn()  # sub system may have turn-based effects, such as bleeding
            if x.value() < x.max_value:
                regen = self.regeneration()
                x.change_cur_value(regen)
                battle_log.add('%s [%s] condition regenerated by +%d' % (self.name, x.name, regen))

    def take_damage(self, damage):
        if isinstance(damage, MixedDamage):
            damages = damage.lst
        else:
            damages = [damage]  # make it a list
        for dmg in damages:
            if isinstance(dmg, SlashingDamage):
                self.m.take_damage(dmg)
            elif isinstance(dmg, BleedingDamage):
                self.c.take_damage(dmg)
            elif isinstance(dmg, CrushingDamage):
                self.s.take_damage(dmg)


class Intelligent(Living):
    """Intelligent Living can use (non-natural) weapon and armor
    """

    def wield(self, weapon):
        assert isinstance(weapon, Weapon), '%s: must input instance of Weapon' % self.__class__.__name__
        self.weapon = weapon

    def wear(self, armor):
        assert isinstance(armor, Armor), '%s: must input instance of Armor' % self.__class__.__name__
        self.armor = armor


if __name__ == "__main__":
    player = Intelligent('Player', 100, 100, 100, 100)
    player.wield(Sword())
    player.wear(LeatherArmor())
    monster = Intelligent('Ogre', 300, 100, 150, 100, weight=500)  # stronger muscle and sensory system, but weight slows it down
    monster.wield(Club())
    turn = 0
    while True:
        turn += 1
        print('Turn %d' % turn)
        if not player.is_unconscious():
            monster.defend(player.attack())
        if not monster.is_unconscious():
            player.defend(monster.attack())
        battle_log.flush()
        for being in [player, monster]:
            conds = [x.cur_value for x in being.damageable]
            being.take_turn()
            print('%s %s (%s)' % (being.name, conds, being.status()))
        if player.is_dead() or monster.is_dead():
            break
